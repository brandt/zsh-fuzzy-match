fuzzy-match() {
	emulate -L zsh
	setopt local_options extended_glob
	unsetopt monitor

	# Save current zle state
	typeset -Ag old_state state
	old_state=(
		LBUFFER "$LBUFFER"
		RBUFFER "$RBUFFER"
		PREDISPLAY "$PREDISPLAY"
		POSTDISPLAY "$POSTDISPLAY"
	)
	if [[ ${#region_highlight} -ne 0 ]]; then 
		set -a "old_state[region_highlight]" ("${region_highlight[@]}")
	fi
	# The first item in 'region_highlight' is used for the line cursor
	region_highlight=("")

	# TODO find a way to match newlines in subcript glob patterns without using
	# this hack
 	IFS=$'\n'
	# widget-specific state, global for easy sharing across functions.
	state=(
		nl '[[:IFS:]]'
		selected_line 0
		last_selected_line 0
		max_lines $(($LINES - 2)) # 1 line for the prompt, another for status
		max_columns $COLUMNS
		lines 0
	)

	# initialize configuration
	zstyle -s ':fuzzy-match:highlight' selected "state[hi_selected]" ||\
	 	state[hi_selected]='standout'
	zstyle -s ':fuzzy-match:highlight' matched "state[hi_matched]" ||\
	 	state[hi_matched]='fg=magenta,underline'
	zstyle -s ':fuzzy-match:highlight' title "state[hi_title]" ||\
	 	state[hi_title]='bold'

	# initialize source program
	#
	# it can be any program that will listen on standard input for search
	# patterns, and send back results to standard output.
	#
	# there's no input protocol, each input line represents a search pattern. if
	# the source is still searching for
	#
	# the output protocol only two possible types of message:
	# CLEAR: clear the results
	# APPEND-RESULT: append a single matched result
	#
	local source_prog=$1
	if [[ -z $source_prog ]]; then
		source_prog="_fuzzy-match-file-glob"
	fi

	# create named pipe for reading from the source coprocess
	local ipc_pipe="/tmp/fuzzy-match-buffer-$RANDOM"
	while ! mkfifo -m 600 $ipc_pipe; do
		ipc_pipe="/tmp/fuzzy-match-buffer-$RANDOM"
	done

	# open the pipe for reading/writing
	# (I couldn't get zle -F to work when opening only for reading, which is what
	# we need here)
	exec 3<>$ipc_pipe

	# make zle listen on the pipe
	zle -F 3 _fuzzy-match-update-results

	# start the source prog with output redirected to the ipc_pipe
	{ coproc $source_prog $state[max_lines] > $ipc_pipe }
	local source_pid=$!

	# Intercept self-insert, {up,down}-line-or-history
	zle -N self-insert _fuzzy-match-self-insert
	zle -N up-line-or-history _fuzzy-match-go-up
	zle -N down-line-or-history _fuzzy-match-go-down

	# use recursive edit, so we inherit the user keymap and override only what is
	# needed
	zle recursive-edit
	local edit_status=$?

	# restore default widgets
	zle -A .self-insert self-insert
	zle -A .up-line-or-history up-line-or-history
	zle -A .down-line-or-history down-line-or-history

	# restore initial zle state
	LBUFFER="$old_state[LBUFFER]"
	RBUFFER="$old_state[RBUFFER]"
	PREDISPLAY="$old_state[PREDISPLAY]"
	POSTDISPLAY="$old_state[POSTDISPLAY]"
	if [[ -n $old_state[region_highlight] ]]; then
		region_highlight=("$old_state[region_highlight][@]")
	fi

	# refresh
	zle -Rc

	# delete globals set
	unset old_state state IFS

	# cleanup source process
	kill $source_pid &> /dev/null
	exec 3>&-
	rm -f $ipc_pipe

	# if interrupted, just exit and don't do anything else
	(( edit_status )) && zle send-break

	printf "done"
}

_fuzzy-match-update-results() {
	local cmd item hi_selected=$state[hi_selected]
	integer buffer_len
	while read -t -d $'\0' -r -u $1 cmd; do
		case $cmd in
			CLEAR)
				POSTDISPLAY=''
				state[lines]=0
				state[selected_line]=0
				state[last_selected_line]=0
				;;
			APPEND-RESULT:*)
				item=${cmd#APPEND\-RESULT\:}
				POSTDISPLAY+=$'\n'
				POSTDISPLAY+=$item
				(( state[lines]++ ))
				if (( state[selected_line] == 0 )); then
					# automatically select the first line
					buffer_len=${#BUFFER}
					state[selected_line]=1
					region_highlight[1]="$(( 1 + buffer_len )) $(( $#item + 1 + buffer_len )) $hi_selected"
				fi
				state[incomplete_line]=''
				;;
		esac
	done
	zle -Rc
}

zle -N fuzzy-match
