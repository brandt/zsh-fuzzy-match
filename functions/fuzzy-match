# Main widget logic.
# The source can be any program that understands a simple protocol via stdio
#
# It can send:
#
#		CLEAR - Clears the output list
#		APPEND:[result] - Appends a single result to the output list
#		GET - Queries for the currently typed pattern
#	
#	It should also accept:
#	
#		PATTERN:[pattern] - This is the response to GET
#		RESTART - Stop yielding matches and start again(this happens when the
#							user modified the text)
#
# Every message in the protocol should be terminated with the null byte(0)
fuzzy-match() {
	emulate -L zsh
	setopt local_options extended_glob
	unsetopt monitor

	# Save current zle state
	typeset -Ag old_state state
	old_state=(
	LBUFFER "$LBUFFER"
	RBUFFER "$RBUFFER"
	PREDISPLAY "$PREDISPLAY"
	POSTDISPLAY "$POSTDISPLAY"
	)
	if [[ ${#region_highlight} -ne 0 ]]; then 
		set -a "old_state[region_highlight]" ("${region_highlight[@]}")
	fi

	# TODO find a way to match newlines in subcript glob patterns without using
	# this hack
	IFS=$'\n'
	# widget-specific state, global for easy sharing across functions.
	state=(
	nl '[[:IFS:]]'
	selected_line 0
	last_selected_line 0
	lines 0
	max_lines $(( LINES - 3 ))
	)

	# initialize configuration
	zstyle -s ':fuzzy-match:highlight' selected "state[hi_selected]" ||\
		state[hi_selected]='standout'
	zstyle -s ':fuzzy-match:highlight' matched "state[hi_matched]" ||\
		state[hi_matched]='fg=magenta,underline'
	zstyle -s ':fuzzy-match:highlight' title "state[hi_title]" ||\
		state[hi_title]='bold'

	# The first item in 'region_highlight' is used for the line cursor, second for
	# the title
	PREDISPLAY=$'\nFuzzy match: '
	region_highlight=("" "P1 13 $state[hi_title]")

	# initialize source program
	local source_prog=$1
	if [[ -z $source_prog ]]; then
		source_prog="_fuzzy-match-file-glob"
	fi

	# start the source prog as a coprocess
	coproc $source_prog $state[max_lines]
	local source_pid=$! 
	disown
	local coproc_out

	# copy coproc fd to $coproc_out so it can be used by zle -F
	exec {coproc_out}<&p

	# make zle invoke _fuzzy-match-coproc-receive
	zle -F $coproc_out _fuzzy-match-coproc-receive

	# Intercept self-insert, {up,down}-line-or-history
	zle -N self-insert _fuzzy-match-self-insert
	zle -N up-line-or-history _fuzzy-match-go-up
	zle -N down-line-or-history _fuzzy-match-go-down

	# use recursive edit, so we inherit the user keymap and override only what is
	# needed
	zle recursive-edit
	local edit_status=$?

	# restore default widgets
	zle -A .self-insert self-insert
	zle -A .up-line-or-history up-line-or-history
	zle -A .down-line-or-history down-line-or-history

	# restore initial zle state
	LBUFFER="$old_state[LBUFFER]"
	RBUFFER="$old_state[RBUFFER]"
	PREDISPLAY="$old_state[PREDISPLAY]"
	POSTDISPLAY="$old_state[POSTDISPLAY]"
	if [[ -n $old_state[region_highlight] ]]; then
		region_highlight=("$old_state[region_highlight][@]")
	fi

	# refresh
	zle -Rc

	# delete globals set
	unset old_state state IFS

	# cleanup source process
	kill $source_pid &> /dev/null

	# if interrupted, just exit and don't do anything else
	(( edit_status )) && zle send-break
}

_fuzzy-match-coproc-receive() {
	local cmd item hi_selected=$state[hi_selected]
	integer buffer_len
	if read -d $'\0' -r -u $1 cmd; then
		case $cmd in
			CLEAR)
				POSTDISPLAY=''
				state[lines]=0
				state[selected_line]=0
				state[last_selected_line]=0
				;;
			APPEND*)
				(( state[lines] == state[max_lines] )) && return
				item=${cmd#APPEND\:}
				POSTDISPLAY+=$'\n'
				POSTDISPLAY+=$item
				(( state[lines]++ ))
				if (( state[selected_line] == 0 )); then
					# automatically select the first line
					buffer_len=${#BUFFER}
					state[selected_line]=1
					region_highlight[1]="$(( 1 + buffer_len )) $(( $#item + 1 + buffer_len )) $hi_selected"
				fi
				state[incomplete_line]=''
				;;
			GET) # this may come with leading garbage from job control
				print -p -N "PATTERN:$BUFFER"
				;;
		esac
		zle -Rc
	fi
}

zle -N fuzzy-match
