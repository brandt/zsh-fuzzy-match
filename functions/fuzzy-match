fuzzy-match() {
	emulate -L zsh
	setopt local_options extended_glob
	unsetopt monitor

	# Save current zle state
	typeset -Ag old_state state
	old_state=(
		LBUFFER "$LBUFFER"
		RBUFFER "$RBUFFER"
		PREDISPLAY "$PREDISPLAY"
		POSTDISPLAY "$POSTDISPLAY"
	)
	if [[ ${#region_highlight} -ne 0 ]]; then 
		set -a "old_state[region_highlight]" ("${region_highlight[@]}")
	fi

	# TODO find a way to match newlines in subcript glob patterns without using
	# this hack
 	IFS=$'\n'
	# widget-specific state, global for easy sharing across functions.
	state=(
		nl '[[:IFS:]]'
		selected_line 0
		last_selected_line 0
		lines 0
		max_lines $(( LINES - 4 ))
	)

	# initialize configuration
	zstyle -s ':fuzzy-match:highlight' selected "state[hi_selected]" ||\
	 	state[hi_selected]='standout'
	zstyle -s ':fuzzy-match:highlight' matched "state[hi_matched]" ||\
	 	state[hi_matched]='fg=magenta,underline'
	zstyle -s ':fuzzy-match:highlight' title "state[hi_title]" ||\
	 	state[hi_title]='bold'

	# The first item in 'region_highlight' is used for the line cursor, second for
	# the title
	PREDISPLAY=$'\nFuzzy match: '
	region_highlight=("" "P1 13 $state[hi_title]")

	# initialize source program
	#
	# it can be any program that understands a simple protocol via stdio
	#
	# The source prog can send the following messages:
	#
	#		CLEAR - Clears the output list
	#		APPEND-RESULT:[result] - Appends a single result to the output list
	#		GET-PATTERN - Queries for the currently typed pattern
	#	
	#	It should also accept the following:
	#	
	#		PATTERN:[pattern] - This is the response to GET-PATTERN
	#		RESTART - Stop yielding matches and start again(this happens when the
	#							user modified the text)
	#
	# Every message in the protocol should be terminated with the null byte(0)
	#
	local source_prog=$1
	if [[ -z $source_prog ]]; then
		source_prog="_fuzzy-match-file-glob"
	fi

	# create named pipe for reading from the source coprocess
	local ipc_pipe="/tmp/fuzzy-match-buffer-$RANDOM"
	while ! mkfifo -m 600 $ipc_pipe; do
		ipc_pipe="/tmp/fuzzy-match-buffer-$RANDOM"
	done

	# open the pipe for reading/writing
	# (I couldn't get zle -F to work when opening only for reading, which is what
	# we need here)
	exec 3<>$ipc_pipe

	# make zle listen on the pipe
	zle -F 3 _fuzzy-match-update-results

	# start the source prog with output redirected to the ipc_pipe
	{ coproc $source_prog $state[max_lines] > $ipc_pipe }
	local source_pid=$!

	# Intercept self-insert, {up,down}-line-or-history
	zle -N self-insert _fuzzy-match-self-insert
	zle -N up-line-or-history _fuzzy-match-go-up
	zle -N down-line-or-history _fuzzy-match-go-down

	# use recursive edit, so we inherit the user keymap and override only what is
	# needed
	zle recursive-edit
	local edit_status=$?

	# restore default widgets
	zle -A .self-insert self-insert
	zle -A .up-line-or-history up-line-or-history
	zle -A .down-line-or-history down-line-or-history

	# restore initial zle state
	LBUFFER="$old_state[LBUFFER]"
	RBUFFER="$old_state[RBUFFER]"
	PREDISPLAY="$old_state[PREDISPLAY]"
	POSTDISPLAY="$old_state[POSTDISPLAY]"
	if [[ -n $old_state[region_highlight] ]]; then
		region_highlight=("$old_state[region_highlight][@]")
	fi

	# refresh
	zle -Rc

	# delete globals set
	unset old_state state IFS

	# cleanup source process
	kill $source_pid &> /dev/null
	exec 3>&-
	rm -f $ipc_pipe

	# if interrupted, just exit and don't do anything else
	(( edit_status )) && zle send-break
}

_fuzzy-match-update-results() {
	local cmd item hi_selected=$state[hi_selected]
	integer buffer_len
	while read -t -d $'\0' -r -u $1 cmd; do
		case $cmd in
			CLEAR)
				POSTDISPLAY=''
				state[lines]=0
				state[selected_line]=0
				state[last_selected_line]=0
				;;
			APPEND-RESULT:*)
				(( state[lines] == state[max_lines] )) && continue # discard
				item=${cmd#APPEND\-RESULT\:}
				POSTDISPLAY+=$'\n'
				POSTDISPLAY+=$item
				(( state[lines]++ ))
				if (( state[selected_line] == 0 )); then
					# automatically select the first line
					buffer_len=${#BUFFER}
					state[selected_line]=1
					region_highlight[1]="$(( 1 + buffer_len )) $(( $#item + 1 + buffer_len )) $hi_selected"
				fi
				state[incomplete_line]=''
				;;
			GET-PATTERN) # this may come with leading garbage from job control
				print -p -N "PATTERN:$BUFFER"
				;;
		esac
		zle -Rc
	done
}

zle -N fuzzy-match
